{"ast":null,"code":"import * as parseley from 'parseley';\nimport { compareSpecificity } from 'parseley';\nvar Ast = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\nvar Types = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n/**\r\n * A {@link BuilderFunction} implementation.\r\n *\r\n * Produces a string representation of the tree\r\n * for testing and debug purposes.\r\n *\r\n * Only accepts `string` as the associated value type.\r\n * Map your input collection before creating a {@link DecisionTree}\r\n * if you want to use it with a different type -\r\n * the decision on how to stringify the value is up to you.\r\n *\r\n * @param nodes - nodes from the root level of the decision tree.\r\n * @returns the string representation of the tree.\r\n */\n\nconst treeify = nodes => '▽\\n' + treeifyArray(nodes, thinLines);\n\nconst thinLines = [['├─', '│ '], ['└─', '  ']];\nconst heavyLines = [['┠─', '┃ '], ['┖─', '  ']];\nconst doubleLines = [['╟─', '║ '], ['╙─', '  ']];\n\nfunction treeifyArray(nodes, tpl = heavyLines) {\n  return prefixItems(tpl, nodes.map(n => treeifyNode(n)));\n}\n\nfunction treeifyNode(node) {\n  switch (node.type) {\n    case 'terminal':\n      {\n        const vctr = node.valueContainer;\n        return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;\n      }\n\n    case 'tagName':\n      return `◻ Tag name\\n${treeifyArray(node.variants, doubleLines)}`;\n\n    case 'attrValue':\n      return `▣ Attr value: ${node.name}\\n${treeifyArray(node.matchers, doubleLines)}`;\n\n    case 'attrPresence':\n      return `◨ Attr presence: ${node.name}\\n${treeifyArray(node.cont)}`;\n\n    case 'pushElement':\n      return `◉ Push element: ${node.combinator}\\n${treeifyArray(node.cont, thinLines)}`;\n\n    case 'popElement':\n      return `◌ Pop element\\n${treeifyArray(node.cont, thinLines)}`;\n\n    case 'variant':\n      return `◇ = ${node.value}\\n${treeifyArray(node.cont)}`;\n\n    case 'matcher':\n      return `◈ ${node.matcher} \"${node.value}\"${node.modifier || ''}\\n${treeifyArray(node.cont)}`;\n  }\n}\n\nfunction prefixItems(tpl, items) {\n  return items.map((item, i, {\n    length\n  }) => prefixItem(tpl, item, i === length - 1)).join('\\n');\n}\n\nfunction prefixItem(tpl, item, tail = true) {\n  const tpl1 = tpl[tail ? 1 : 0];\n  return tpl1[0] + item.split('\\n').join('\\n' + tpl1[1]);\n}\n\nvar TreeifyBuilder = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  treeify: treeify\n});\n/**\r\n * CSS selectors decision tree.\r\n * Data structure that weaves similar selectors together\r\n * in order to minimize the number of checks required\r\n * to find the ones matching a given HTML element.\r\n *\r\n * Converted into a functioning implementation via plugins\r\n * tailored for specific DOM ASTs.\r\n *\r\n * @typeParam V - the type of values associated with selectors.\r\n */\n\nclass DecisionTree {\n  /**\r\n   * Create new DecisionTree object.\r\n   *\r\n   * @param input - an array containing all selectors\r\n   * paired with associated values.\r\n   *\r\n   * @typeParam V - the type of values associated with selectors.\r\n   */\n  constructor(input) {\n    this.branches = weave(toAstTerminalPairs(input));\n  }\n  /**\r\n   * Turn this decision tree into a usable form.\r\n   *\r\n   * @typeParam R - return type defined by the builder function.\r\n   *\r\n   * @param builder - the builder function.\r\n   *\r\n   * @returns the decision tree in a form ready for use.\r\n   */\n\n\n  build(builder) {\n    return builder(this.branches);\n  }\n\n}\n\nfunction toAstTerminalPairs(array) {\n  const len = array.length;\n  const results = new Array(len);\n\n  for (let i = 0; i < len; i++) {\n    const [selectorString, val] = array[i];\n    const ast = preprocess(parseley.parse1(selectorString));\n    results[i] = {\n      ast: ast,\n      terminal: {\n        type: 'terminal',\n        valueContainer: {\n          index: i,\n          value: val,\n          specificity: ast.specificity\n        }\n      }\n    };\n  }\n\n  return results;\n}\n\nfunction preprocess(ast) {\n  reduceSelectorVariants(ast);\n  parseley.normalize(ast);\n  return ast;\n}\n\nfunction reduceSelectorVariants(ast) {\n  const newList = [];\n  ast.list.forEach(sel => {\n    switch (sel.type) {\n      case 'class':\n        newList.push({\n          matcher: '~=',\n          modifier: null,\n          name: 'class',\n          namespace: null,\n          specificity: sel.specificity,\n          type: 'attrValue',\n          value: sel.name\n        });\n        break;\n\n      case 'id':\n        newList.push({\n          matcher: '=',\n          modifier: null,\n          name: 'id',\n          namespace: null,\n          specificity: sel.specificity,\n          type: 'attrValue',\n          value: sel.name\n        });\n        break;\n\n      case 'combinator':\n        reduceSelectorVariants(sel.left);\n        newList.push(sel);\n        break;\n\n      case 'universal':\n        // skip it\n        break;\n\n      default:\n        newList.push(sel);\n        break;\n    }\n  });\n  ast.list = newList;\n}\n\nfunction weave(items) {\n  const branches = [];\n\n  while (items.length) {\n    const topKind = findTopKey(items, sel => true, getSelectorKind);\n    const {\n      matches,\n      nonmatches,\n      empty\n    } = breakByKind(items, topKind);\n    items = nonmatches;\n\n    if (matches.length) {\n      branches.push(branchOfKind(topKind, matches));\n    }\n\n    if (empty.length) {\n      branches.push(...terminate(empty));\n    }\n  }\n\n  return branches;\n}\n\nfunction terminate(items) {\n  const results = [];\n\n  for (const item of items) {\n    const terminal = item.terminal;\n\n    if (terminal.type === 'terminal') {\n      results.push(terminal);\n    } else {\n      // popElement - lift contained terminals\n      const {\n        matches,\n        rest\n      } = partition(terminal.cont, node => node.type === 'terminal');\n      matches.forEach(node => results.push(node));\n\n      if (rest.length) {\n        terminal.cont = rest;\n        results.push(terminal);\n      }\n    }\n  }\n\n  return results;\n}\n\nfunction breakByKind(items, selectedKind) {\n  const matches = [];\n  const nonmatches = [];\n  const empty = [];\n\n  for (const item of items) {\n    const simpsels = item.ast.list;\n\n    if (simpsels.length) {\n      const isMatch = simpsels.some(node => getSelectorKind(node) === selectedKind);\n      (isMatch ? matches : nonmatches).push(item);\n    } else {\n      empty.push(item);\n    }\n  }\n\n  return {\n    matches,\n    nonmatches,\n    empty\n  };\n}\n\nfunction getSelectorKind(sel) {\n  switch (sel.type) {\n    case 'attrPresence':\n      return `attrPresence ${sel.name}`;\n\n    case 'attrValue':\n      return `attrValue ${sel.name}`;\n\n    case 'combinator':\n      return `combinator ${sel.combinator}`;\n\n    default:\n      return sel.type;\n  }\n}\n\nfunction branchOfKind(kind, items) {\n  if (kind === 'tag') {\n    return tagNameBranch(items);\n  }\n\n  if (kind.startsWith('attrValue ')) {\n    return attrValueBranch(kind.substring(10), items);\n  }\n\n  if (kind.startsWith('attrPresence ')) {\n    return attrPresenceBranch(kind.substring(13), items);\n  }\n\n  if (kind === 'combinator >') {\n    return combinatorBranch('>', items);\n  }\n\n  if (kind === 'combinator +') {\n    return combinatorBranch('+', items);\n  }\n\n  throw new Error(`Unsupported selector kind: ${kind}`);\n}\n\nfunction tagNameBranch(items) {\n  const groups = spliceAndGroup(items, x => x.type === 'tag', x => x.name);\n  const variants = Object.entries(groups).map(([name, group]) => ({\n    type: 'variant',\n    value: name,\n    cont: weave(group.items)\n  }));\n  return {\n    type: 'tagName',\n    variants: variants\n  };\n}\n\nfunction attrPresenceBranch(name, items) {\n  for (const item of items) {\n    spliceSimpleSelector(item, x => x.type === 'attrPresence' && x.name === name);\n  }\n\n  return {\n    type: 'attrPresence',\n    name: name,\n    cont: weave(items)\n  };\n}\n\nfunction attrValueBranch(name, items) {\n  const groups = spliceAndGroup(items, x => x.type === 'attrValue' && x.name === name, x => `${x.matcher} ${x.modifier || ''} ${x.value}`);\n  const matchers = [];\n\n  for (const group of Object.values(groups)) {\n    const sel = group.oneSimpleSelector;\n    const predicate = getAttrPredicate(sel);\n    const continuation = weave(group.items);\n    matchers.push({\n      type: 'matcher',\n      matcher: sel.matcher,\n      modifier: sel.modifier,\n      value: sel.value,\n      predicate: predicate,\n      cont: continuation\n    });\n  }\n\n  return {\n    type: 'attrValue',\n    name: name,\n    matchers: matchers\n  };\n}\n\nfunction getAttrPredicate(sel) {\n  if (sel.modifier === 'i') {\n    const expected = sel.value.toLowerCase();\n\n    switch (sel.matcher) {\n      case '=':\n        return actual => expected === actual.toLowerCase();\n\n      case '~=':\n        return actual => actual.toLowerCase().split(/[ \\t]+/).includes(expected);\n\n      case '^=':\n        return actual => actual.toLowerCase().startsWith(expected);\n\n      case '$=':\n        return actual => actual.toLowerCase().endsWith(expected);\n\n      case '*=':\n        return actual => actual.toLowerCase().includes(expected);\n\n      case '|=':\n        return actual => {\n          const lower = actual.toLowerCase();\n          return expected === lower || lower.startsWith(expected) && lower[expected.length] === '-';\n        };\n    }\n  } else {\n    const expected = sel.value;\n\n    switch (sel.matcher) {\n      case '=':\n        return actual => expected === actual;\n\n      case '~=':\n        return actual => actual.split(/[ \\t]+/).includes(expected);\n\n      case '^=':\n        return actual => actual.startsWith(expected);\n\n      case '$=':\n        return actual => actual.endsWith(expected);\n\n      case '*=':\n        return actual => actual.includes(expected);\n\n      case '|=':\n        return actual => expected === actual || actual.startsWith(expected) && actual[expected.length] === '-';\n    }\n  }\n}\n\nfunction combinatorBranch(combinator, items) {\n  const groups = spliceAndGroup(items, x => x.type === 'combinator' && x.combinator === combinator, x => parseley.serialize(x.left));\n  const leftItems = [];\n\n  for (const group of Object.values(groups)) {\n    const rightCont = weave(group.items);\n    const leftAst = group.oneSimpleSelector.left;\n    leftItems.push({\n      ast: leftAst,\n      terminal: {\n        type: 'popElement',\n        cont: rightCont\n      }\n    });\n  }\n\n  return {\n    type: 'pushElement',\n    combinator: combinator,\n    cont: weave(leftItems)\n  };\n}\n\nfunction spliceAndGroup(items, predicate, keyCallback) {\n  const groups = {};\n\n  while (items.length) {\n    const bestKey = findTopKey(items, predicate, keyCallback);\n\n    const bestKeyPredicate = sel => predicate(sel) && keyCallback(sel) === bestKey;\n\n    const hasBestKeyPredicate = item => item.ast.list.some(bestKeyPredicate);\n\n    const {\n      matches,\n      rest\n    } = partition1(items, hasBestKeyPredicate);\n    let oneSimpleSelector = null;\n\n    for (const item of matches) {\n      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);\n\n      if (!oneSimpleSelector) {\n        oneSimpleSelector = splicedNode;\n      }\n    }\n\n    if (oneSimpleSelector == null) {\n      throw new Error('No simple selector is found.');\n    }\n\n    groups[bestKey] = {\n      oneSimpleSelector: oneSimpleSelector,\n      items: matches\n    };\n    items = rest;\n  }\n\n  return groups;\n}\n\nfunction spliceSimpleSelector(item, predicate) {\n  const simpsels = item.ast.list;\n  const matches = new Array(simpsels.length);\n  let firstIndex = -1;\n\n  for (let i = simpsels.length; i-- > 0;) {\n    if (predicate(simpsels[i])) {\n      matches[i] = true;\n      firstIndex = i;\n    }\n  }\n\n  if (firstIndex == -1) {\n    throw new Error(`Couldn't find the required simple selector.`);\n  }\n\n  const result = simpsels[firstIndex];\n  item.ast.list = simpsels.filter((sel, i) => !matches[i]);\n  return result;\n}\n\nfunction findTopKey(items, predicate, keyCallback) {\n  const candidates = {};\n\n  for (const item of items) {\n    const candidates1 = {};\n\n    for (const node of item.ast.list.filter(predicate)) {\n      candidates1[keyCallback(node)] = true;\n    }\n\n    for (const key of Object.keys(candidates1)) {\n      if (candidates[key]) {\n        candidates[key]++;\n      } else {\n        candidates[key] = 1;\n      }\n    }\n  }\n\n  let topKind = '';\n  let topCounter = 0;\n\n  for (const entry of Object.entries(candidates)) {\n    if (entry[1] > topCounter) {\n      topKind = entry[0];\n      topCounter = entry[1];\n    }\n  }\n\n  return topKind;\n}\n\nfunction partition(src, predicate) {\n  const matches = [];\n  const rest = [];\n\n  for (const x of src) {\n    if (predicate(x)) {\n      matches.push(x);\n    } else {\n      rest.push(x);\n    }\n  }\n\n  return {\n    matches,\n    rest\n  };\n}\n\nfunction partition1(src, predicate) {\n  const matches = [];\n  const rest = [];\n\n  for (const x of src) {\n    if (predicate(x)) {\n      matches.push(x);\n    } else {\n      rest.push(x);\n    }\n  }\n\n  return {\n    matches,\n    rest\n  };\n}\n/**\r\n * Simple wrapper around the matcher function.\r\n * Recommended return type for builder plugins.\r\n *\r\n * @typeParam L - the type of HTML Element in the targeted DOM AST.\r\n * @typeParam V - the type of associated values.\r\n */\n\n\nclass Picker {\n  /**\r\n   * Create new Picker object.\r\n   *\r\n   * @typeParam L - the type of HTML Element in the targeted DOM AST.\r\n   * @typeParam V - the type of associated values.\r\n   *\r\n   * @param f - the function that matches an element\r\n   * and returns all associated values.\r\n   */\n  constructor(f) {\n    this.f = f;\n  }\n  /**\r\n   * Run the selectors decision tree against one HTML Element\r\n   * and return all matched associated values\r\n   * along with selector specificities.\r\n   *\r\n   * Client code then decides how to further process them\r\n   * (sort, filter, etc).\r\n   *\r\n   * @param el - an HTML Element.\r\n   *\r\n   * @returns all associated values along with\r\n   * selector specificities for all matched selectors.\r\n   */\n\n\n  pickAll(el) {\n    return this.f(el);\n  }\n  /**\r\n   * Run the selectors decision tree against one HTML Element\r\n   * and choose the value from the most specific mached selector.\r\n   *\r\n   * @param el - an HTML Element.\r\n   *\r\n   * @param preferFirst - option to define which value to choose\r\n   * when there are multiple matches with equal specificity.\r\n   *\r\n   * @returns the value from the most specific mached selector\r\n   * or `null` if nothing matched.\r\n   */\n\n\n  pick1(el, preferFirst = false) {\n    const results = this.f(el);\n    const len = results.length;\n\n    if (len === 0) {\n      return null;\n    }\n\n    if (len === 1) {\n      return results[0].value;\n    }\n\n    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;\n    let result = results[0];\n\n    for (let i = 1; i < len; i++) {\n      const next = results[i];\n\n      if (comparator(result, next)) {\n        result = next;\n      }\n    }\n\n    return result.value;\n  }\n\n}\n\nfunction comparatorPreferFirst(acc, next) {\n  const diff = compareSpecificity(next.specificity, acc.specificity);\n  return diff > 0 || diff === 0 && next.index < acc.index;\n}\n\nfunction comparatorPreferLast(acc, next) {\n  const diff = compareSpecificity(next.specificity, acc.specificity);\n  return diff > 0 || diff === 0 && next.index > acc.index;\n}\n\nexport { Ast, DecisionTree, Picker, TreeifyBuilder as Treeify, Types };","map":{"version":3,"sources":["C:/Users/m2bab/VM/rd2/frontend/node_modules/selderee/lib/selderee.mjs"],"names":["parseley","compareSpecificity","Ast","Object","freeze","__proto__","Types","treeify","nodes","treeifyArray","thinLines","heavyLines","doubleLines","tpl","prefixItems","map","n","treeifyNode","node","type","vctr","valueContainer","index","JSON","stringify","specificity","value","variants","name","matchers","cont","combinator","matcher","modifier","items","item","i","length","prefixItem","join","tail","tpl1","split","TreeifyBuilder","DecisionTree","constructor","input","branches","weave","toAstTerminalPairs","build","builder","array","len","results","Array","selectorString","val","ast","preprocess","parse1","terminal","reduceSelectorVariants","normalize","newList","list","forEach","sel","push","namespace","left","topKind","findTopKey","getSelectorKind","matches","nonmatches","empty","breakByKind","branchOfKind","terminate","rest","partition","selectedKind","simpsels","isMatch","some","kind","tagNameBranch","startsWith","attrValueBranch","substring","attrPresenceBranch","combinatorBranch","Error","groups","spliceAndGroup","x","entries","group","spliceSimpleSelector","values","oneSimpleSelector","predicate","getAttrPredicate","continuation","expected","toLowerCase","actual","includes","endsWith","lower","serialize","leftItems","rightCont","leftAst","keyCallback","bestKey","bestKeyPredicate","hasBestKeyPredicate","partition1","splicedNode","firstIndex","result","filter","candidates","candidates1","key","keys","topCounter","entry","src","Picker","f","pickAll","el","pick1","preferFirst","comparator","comparatorPreferFirst","comparatorPreferLast","next","acc","diff","Treeify"],"mappings":"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","sourcesContent":["import * as parseley from 'parseley';\nimport { compareSpecificity } from 'parseley';\n\nvar Ast = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nvar Types = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n/**\r\n * A {@link BuilderFunction} implementation.\r\n *\r\n * Produces a string representation of the tree\r\n * for testing and debug purposes.\r\n *\r\n * Only accepts `string` as the associated value type.\r\n * Map your input collection before creating a {@link DecisionTree}\r\n * if you want to use it with a different type -\r\n * the decision on how to stringify the value is up to you.\r\n *\r\n * @param nodes - nodes from the root level of the decision tree.\r\n * @returns the string representation of the tree.\r\n */\r\nconst treeify = (nodes) => '▽\\n' + treeifyArray(nodes, thinLines);\r\nconst thinLines = [['├─', '│ '], ['└─', '  ']];\r\nconst heavyLines = [['┠─', '┃ '], ['┖─', '  ']];\r\nconst doubleLines = [['╟─', '║ '], ['╙─', '  ']];\r\nfunction treeifyArray(nodes, tpl = heavyLines) {\r\n    return prefixItems(tpl, nodes.map(n => treeifyNode(n)));\r\n}\r\nfunction treeifyNode(node) {\r\n    switch (node.type) {\r\n        case 'terminal': {\r\n            const vctr = node.valueContainer;\r\n            return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;\r\n        }\r\n        case 'tagName':\r\n            return `◻ Tag name\\n${treeifyArray(node.variants, doubleLines)}`;\r\n        case 'attrValue':\r\n            return `▣ Attr value: ${node.name}\\n${treeifyArray(node.matchers, doubleLines)}`;\r\n        case 'attrPresence':\r\n            return `◨ Attr presence: ${node.name}\\n${treeifyArray(node.cont)}`;\r\n        case 'pushElement':\r\n            return `◉ Push element: ${node.combinator}\\n${treeifyArray(node.cont, thinLines)}`;\r\n        case 'popElement':\r\n            return `◌ Pop element\\n${treeifyArray(node.cont, thinLines)}`;\r\n        case 'variant':\r\n            return `◇ = ${node.value}\\n${treeifyArray(node.cont)}`;\r\n        case 'matcher':\r\n            return `◈ ${node.matcher} \"${node.value}\"${node.modifier || ''}\\n${treeifyArray(node.cont)}`;\r\n    }\r\n}\r\nfunction prefixItems(tpl, items) {\r\n    return items\r\n        .map((item, i, { length }) => prefixItem(tpl, item, i === length - 1))\r\n        .join('\\n');\r\n}\r\nfunction prefixItem(tpl, item, tail = true) {\r\n    const tpl1 = tpl[tail ? 1 : 0];\r\n    return tpl1[0] + item.split('\\n').join('\\n' + tpl1[1]);\r\n}\n\nvar TreeifyBuilder = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    treeify: treeify\n});\n\n/**\r\n * CSS selectors decision tree.\r\n * Data structure that weaves similar selectors together\r\n * in order to minimize the number of checks required\r\n * to find the ones matching a given HTML element.\r\n *\r\n * Converted into a functioning implementation via plugins\r\n * tailored for specific DOM ASTs.\r\n *\r\n * @typeParam V - the type of values associated with selectors.\r\n */\r\nclass DecisionTree {\r\n    /**\r\n     * Create new DecisionTree object.\r\n     *\r\n     * @param input - an array containing all selectors\r\n     * paired with associated values.\r\n     *\r\n     * @typeParam V - the type of values associated with selectors.\r\n     */\r\n    constructor(input) {\r\n        this.branches = weave(toAstTerminalPairs(input));\r\n    }\r\n    /**\r\n     * Turn this decision tree into a usable form.\r\n     *\r\n     * @typeParam R - return type defined by the builder function.\r\n     *\r\n     * @param builder - the builder function.\r\n     *\r\n     * @returns the decision tree in a form ready for use.\r\n     */\r\n    build(builder) {\r\n        return builder(this.branches);\r\n    }\r\n}\r\nfunction toAstTerminalPairs(array) {\r\n    const len = array.length;\r\n    const results = new Array(len);\r\n    for (let i = 0; i < len; i++) {\r\n        const [selectorString, val] = array[i];\r\n        const ast = preprocess(parseley.parse1(selectorString));\r\n        results[i] = {\r\n            ast: ast,\r\n            terminal: {\r\n                type: 'terminal',\r\n                valueContainer: { index: i, value: val, specificity: ast.specificity }\r\n            }\r\n        };\r\n    }\r\n    return results;\r\n}\r\nfunction preprocess(ast) {\r\n    reduceSelectorVariants(ast);\r\n    parseley.normalize(ast);\r\n    return ast;\r\n}\r\nfunction reduceSelectorVariants(ast) {\r\n    const newList = [];\r\n    ast.list.forEach(sel => {\r\n        switch (sel.type) {\r\n            case 'class':\r\n                newList.push({\r\n                    matcher: '~=',\r\n                    modifier: null,\r\n                    name: 'class',\r\n                    namespace: null,\r\n                    specificity: sel.specificity,\r\n                    type: 'attrValue',\r\n                    value: sel.name,\r\n                });\r\n                break;\r\n            case 'id':\r\n                newList.push({\r\n                    matcher: '=',\r\n                    modifier: null,\r\n                    name: 'id',\r\n                    namespace: null,\r\n                    specificity: sel.specificity,\r\n                    type: 'attrValue',\r\n                    value: sel.name,\r\n                });\r\n                break;\r\n            case 'combinator':\r\n                reduceSelectorVariants(sel.left);\r\n                newList.push(sel);\r\n                break;\r\n            case 'universal':\r\n                // skip it\r\n                break;\r\n            default:\r\n                newList.push(sel);\r\n                break;\r\n        }\r\n    });\r\n    ast.list = newList;\r\n}\r\nfunction weave(items) {\r\n    const branches = [];\r\n    while (items.length) {\r\n        const topKind = findTopKey(items, (sel) => true, getSelectorKind);\r\n        const { matches, nonmatches, empty } = breakByKind(items, topKind);\r\n        items = nonmatches;\r\n        if (matches.length) {\r\n            branches.push(branchOfKind(topKind, matches));\r\n        }\r\n        if (empty.length) {\r\n            branches.push(...terminate(empty));\r\n        }\r\n    }\r\n    return branches;\r\n}\r\nfunction terminate(items) {\r\n    const results = [];\r\n    for (const item of items) {\r\n        const terminal = item.terminal;\r\n        if (terminal.type === 'terminal') {\r\n            results.push(terminal);\r\n        }\r\n        else { // popElement - lift contained terminals\r\n            const { matches, rest } = partition(terminal.cont, (node) => node.type === 'terminal');\r\n            matches.forEach((node) => results.push(node));\r\n            if (rest.length) {\r\n                terminal.cont = rest;\r\n                results.push(terminal);\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}\r\nfunction breakByKind(items, selectedKind) {\r\n    const matches = [];\r\n    const nonmatches = [];\r\n    const empty = [];\r\n    for (const item of items) {\r\n        const simpsels = item.ast.list;\r\n        if (simpsels.length) {\r\n            const isMatch = simpsels.some(node => getSelectorKind(node) === selectedKind);\r\n            (isMatch ? matches : nonmatches).push(item);\r\n        }\r\n        else {\r\n            empty.push(item);\r\n        }\r\n    }\r\n    return { matches, nonmatches, empty };\r\n}\r\nfunction getSelectorKind(sel) {\r\n    switch (sel.type) {\r\n        case 'attrPresence':\r\n            return `attrPresence ${sel.name}`;\r\n        case 'attrValue':\r\n            return `attrValue ${sel.name}`;\r\n        case 'combinator':\r\n            return `combinator ${sel.combinator}`;\r\n        default:\r\n            return sel.type;\r\n    }\r\n}\r\nfunction branchOfKind(kind, items) {\r\n    if (kind === 'tag') {\r\n        return tagNameBranch(items);\r\n    }\r\n    if (kind.startsWith('attrValue ')) {\r\n        return attrValueBranch(kind.substring(10), items);\r\n    }\r\n    if (kind.startsWith('attrPresence ')) {\r\n        return attrPresenceBranch(kind.substring(13), items);\r\n    }\r\n    if (kind === 'combinator >') {\r\n        return combinatorBranch('>', items);\r\n    }\r\n    if (kind === 'combinator +') {\r\n        return combinatorBranch('+', items);\r\n    }\r\n    throw new Error(`Unsupported selector kind: ${kind}`);\r\n}\r\nfunction tagNameBranch(items) {\r\n    const groups = spliceAndGroup(items, (x) => x.type === 'tag', (x) => x.name);\r\n    const variants = Object.entries(groups).map(([name, group]) => ({\r\n        type: 'variant',\r\n        value: name,\r\n        cont: weave(group.items)\r\n    }));\r\n    return {\r\n        type: 'tagName',\r\n        variants: variants\r\n    };\r\n}\r\nfunction attrPresenceBranch(name, items) {\r\n    for (const item of items) {\r\n        spliceSimpleSelector(item, (x) => (x.type === 'attrPresence') && (x.name === name));\r\n    }\r\n    return {\r\n        type: 'attrPresence',\r\n        name: name,\r\n        cont: weave(items)\r\n    };\r\n}\r\nfunction attrValueBranch(name, items) {\r\n    const groups = spliceAndGroup(items, (x) => (x.type === 'attrValue') && (x.name === name), (x) => `${x.matcher} ${x.modifier || ''} ${x.value}`);\r\n    const matchers = [];\r\n    for (const group of Object.values(groups)) {\r\n        const sel = group.oneSimpleSelector;\r\n        const predicate = getAttrPredicate(sel);\r\n        const continuation = weave(group.items);\r\n        matchers.push({\r\n            type: 'matcher',\r\n            matcher: sel.matcher,\r\n            modifier: sel.modifier,\r\n            value: sel.value,\r\n            predicate: predicate,\r\n            cont: continuation\r\n        });\r\n    }\r\n    return {\r\n        type: 'attrValue',\r\n        name: name,\r\n        matchers: matchers\r\n    };\r\n}\r\nfunction getAttrPredicate(sel) {\r\n    if (sel.modifier === 'i') {\r\n        const expected = sel.value.toLowerCase();\r\n        switch (sel.matcher) {\r\n            case '=':\r\n                return (actual) => expected === actual.toLowerCase();\r\n            case '~=':\r\n                return (actual) => actual.toLowerCase().split(/[ \\t]+/).includes(expected);\r\n            case '^=':\r\n                return (actual) => actual.toLowerCase().startsWith(expected);\r\n            case '$=':\r\n                return (actual) => actual.toLowerCase().endsWith(expected);\r\n            case '*=':\r\n                return (actual) => actual.toLowerCase().includes(expected);\r\n            case '|=':\r\n                return (actual) => {\r\n                    const lower = actual.toLowerCase();\r\n                    return (expected === lower) || (lower.startsWith(expected) && lower[expected.length] === '-');\r\n                };\r\n        }\r\n    }\r\n    else {\r\n        const expected = sel.value;\r\n        switch (sel.matcher) {\r\n            case '=':\r\n                return (actual) => expected === actual;\r\n            case '~=':\r\n                return (actual) => actual.split(/[ \\t]+/).includes(expected);\r\n            case '^=':\r\n                return (actual) => actual.startsWith(expected);\r\n            case '$=':\r\n                return (actual) => actual.endsWith(expected);\r\n            case '*=':\r\n                return (actual) => actual.includes(expected);\r\n            case '|=':\r\n                return (actual) => (expected === actual) || (actual.startsWith(expected) && actual[expected.length] === '-');\r\n        }\r\n    }\r\n}\r\nfunction combinatorBranch(combinator, items) {\r\n    const groups = spliceAndGroup(items, (x) => (x.type === 'combinator') && (x.combinator === combinator), (x) => parseley.serialize(x.left));\r\n    const leftItems = [];\r\n    for (const group of Object.values(groups)) {\r\n        const rightCont = weave(group.items);\r\n        const leftAst = group.oneSimpleSelector.left;\r\n        leftItems.push({\r\n            ast: leftAst,\r\n            terminal: { type: 'popElement', cont: rightCont }\r\n        });\r\n    }\r\n    return {\r\n        type: 'pushElement',\r\n        combinator: combinator,\r\n        cont: weave(leftItems)\r\n    };\r\n}\r\nfunction spliceAndGroup(items, predicate, keyCallback) {\r\n    const groups = {};\r\n    while (items.length) {\r\n        const bestKey = findTopKey(items, predicate, keyCallback);\r\n        const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;\r\n        const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);\r\n        const { matches, rest } = partition1(items, hasBestKeyPredicate);\r\n        let oneSimpleSelector = null;\r\n        for (const item of matches) {\r\n            const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);\r\n            if (!oneSimpleSelector) {\r\n                oneSimpleSelector = splicedNode;\r\n            }\r\n        }\r\n        if (oneSimpleSelector == null) {\r\n            throw new Error('No simple selector is found.');\r\n        }\r\n        groups[bestKey] = { oneSimpleSelector: oneSimpleSelector, items: matches };\r\n        items = rest;\r\n    }\r\n    return groups;\r\n}\r\nfunction spliceSimpleSelector(item, predicate) {\r\n    const simpsels = item.ast.list;\r\n    const matches = new Array(simpsels.length);\r\n    let firstIndex = -1;\r\n    for (let i = simpsels.length; i-- > 0;) {\r\n        if (predicate(simpsels[i])) {\r\n            matches[i] = true;\r\n            firstIndex = i;\r\n        }\r\n    }\r\n    if (firstIndex == -1) {\r\n        throw new Error(`Couldn't find the required simple selector.`);\r\n    }\r\n    const result = simpsels[firstIndex];\r\n    item.ast.list = simpsels.filter((sel, i) => !matches[i]);\r\n    return result;\r\n}\r\nfunction findTopKey(items, predicate, keyCallback) {\r\n    const candidates = {};\r\n    for (const item of items) {\r\n        const candidates1 = {};\r\n        for (const node of item.ast.list.filter(predicate)) {\r\n            candidates1[keyCallback(node)] = true;\r\n        }\r\n        for (const key of Object.keys(candidates1)) {\r\n            if (candidates[key]) {\r\n                candidates[key]++;\r\n            }\r\n            else {\r\n                candidates[key] = 1;\r\n            }\r\n        }\r\n    }\r\n    let topKind = '';\r\n    let topCounter = 0;\r\n    for (const entry of Object.entries(candidates)) {\r\n        if (entry[1] > topCounter) {\r\n            topKind = entry[0];\r\n            topCounter = entry[1];\r\n        }\r\n    }\r\n    return topKind;\r\n}\r\nfunction partition(src, predicate) {\r\n    const matches = [];\r\n    const rest = [];\r\n    for (const x of src) {\r\n        if (predicate(x)) {\r\n            matches.push(x);\r\n        }\r\n        else {\r\n            rest.push(x);\r\n        }\r\n    }\r\n    return { matches, rest };\r\n}\r\nfunction partition1(src, predicate) {\r\n    const matches = [];\r\n    const rest = [];\r\n    for (const x of src) {\r\n        if (predicate(x)) {\r\n            matches.push(x);\r\n        }\r\n        else {\r\n            rest.push(x);\r\n        }\r\n    }\r\n    return { matches, rest };\r\n}\n\n/**\r\n * Simple wrapper around the matcher function.\r\n * Recommended return type for builder plugins.\r\n *\r\n * @typeParam L - the type of HTML Element in the targeted DOM AST.\r\n * @typeParam V - the type of associated values.\r\n */\r\nclass Picker {\r\n    /**\r\n     * Create new Picker object.\r\n     *\r\n     * @typeParam L - the type of HTML Element in the targeted DOM AST.\r\n     * @typeParam V - the type of associated values.\r\n     *\r\n     * @param f - the function that matches an element\r\n     * and returns all associated values.\r\n     */\r\n    constructor(f) {\r\n        this.f = f;\r\n    }\r\n    /**\r\n     * Run the selectors decision tree against one HTML Element\r\n     * and return all matched associated values\r\n     * along with selector specificities.\r\n     *\r\n     * Client code then decides how to further process them\r\n     * (sort, filter, etc).\r\n     *\r\n     * @param el - an HTML Element.\r\n     *\r\n     * @returns all associated values along with\r\n     * selector specificities for all matched selectors.\r\n     */\r\n    pickAll(el) {\r\n        return this.f(el);\r\n    }\r\n    /**\r\n     * Run the selectors decision tree against one HTML Element\r\n     * and choose the value from the most specific mached selector.\r\n     *\r\n     * @param el - an HTML Element.\r\n     *\r\n     * @param preferFirst - option to define which value to choose\r\n     * when there are multiple matches with equal specificity.\r\n     *\r\n     * @returns the value from the most specific mached selector\r\n     * or `null` if nothing matched.\r\n     */\r\n    pick1(el, preferFirst = false) {\r\n        const results = this.f(el);\r\n        const len = results.length;\r\n        if (len === 0) {\r\n            return null;\r\n        }\r\n        if (len === 1) {\r\n            return results[0].value;\r\n        }\r\n        const comparator = (preferFirst)\r\n            ? comparatorPreferFirst\r\n            : comparatorPreferLast;\r\n        let result = results[0];\r\n        for (let i = 1; i < len; i++) {\r\n            const next = results[i];\r\n            if (comparator(result, next)) {\r\n                result = next;\r\n            }\r\n        }\r\n        return result.value;\r\n    }\r\n}\r\nfunction comparatorPreferFirst(acc, next) {\r\n    const diff = compareSpecificity(next.specificity, acc.specificity);\r\n    return diff > 0 || (diff === 0 && next.index < acc.index);\r\n}\r\nfunction comparatorPreferLast(acc, next) {\r\n    const diff = compareSpecificity(next.specificity, acc.specificity);\r\n    return diff > 0 || (diff === 0 && next.index > acc.index);\r\n}\n\nexport { Ast, DecisionTree, Picker, TreeifyBuilder as Treeify, Types };\n"]},"metadata":{},"sourceType":"module"}