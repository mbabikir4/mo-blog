{"ast":null,"code":"import pathToRegexp from 'path-to-regexp';\nvar patternCache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nvar compilePath = function compilePath(pattern, options) {\n  var cacheKey = '' + options.end + options.strict;\n  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n  if (cache[pattern]) return cache[pattern];\n  var keys = [];\n  var re = pathToRegexp(pattern, keys, options);\n  var compiledPattern = {\n    re: re,\n    keys: keys\n  };\n\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledPattern;\n    cacheCount++;\n  }\n\n  return compiledPattern;\n};\n/**\n * Public API for matching a URL pathname to a path pattern.\n */\n\n\nvar matchPath = function matchPath(pathname) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof options === 'string') options = {\n    path: options\n  };\n  var _options = options,\n      _options$path = _options.path,\n      path = _options$path === undefined ? '/' : _options$path,\n      _options$exact = _options.exact,\n      exact = _options$exact === undefined ? false : _options$exact,\n      _options$strict = _options.strict,\n      strict = _options$strict === undefined ? false : _options$strict;\n\n  var _compilePath = compilePath(path, {\n    end: exact,\n    strict: strict\n  }),\n      re = _compilePath.re,\n      keys = _compilePath.keys;\n\n  var match = re.exec(pathname);\n  if (!match) return null;\n  var url = match[0],\n      values = match.slice(1);\n  var isExact = pathname === url;\n  if (exact && !isExact) return null;\n  return {\n    path: path,\n    // the path pattern used to match\n    url: path === '/' && url === '' ? '/' : url,\n    // the matched portion of the URL\n    isExact: isExact,\n    // whether or not we matched exactly\n    params: keys.reduce(function (memo, key, index) {\n      memo[key.name] = values[index];\n      return memo;\n    }, {})\n  };\n};\n\nexport default matchPath;","map":{"version":3,"sources":["C:/Users/m2bab/VM/rd2/frontend/node_modules/admin-on-rest/node_modules/react-router/es/matchPath.js"],"names":["pathToRegexp","patternCache","cacheLimit","cacheCount","compilePath","pattern","options","cacheKey","end","strict","cache","keys","re","compiledPattern","matchPath","pathname","arguments","length","undefined","path","_options","_options$path","_options$exact","exact","_options$strict","_compilePath","match","exec","url","values","slice","isExact","params","reduce","memo","key","index","name"],"mappings":"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","sourcesContent":["import pathToRegexp from 'path-to-regexp';\n\nvar patternCache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nvar compilePath = function compilePath(pattern, options) {\n  var cacheKey = '' + options.end + options.strict;\n  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n\n  if (cache[pattern]) return cache[pattern];\n\n  var keys = [];\n  var re = pathToRegexp(pattern, keys, options);\n  var compiledPattern = { re: re, keys: keys };\n\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledPattern;\n    cacheCount++;\n  }\n\n  return compiledPattern;\n};\n\n/**\n * Public API for matching a URL pathname to a path pattern.\n */\nvar matchPath = function matchPath(pathname) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof options === 'string') options = { path: options };\n\n  var _options = options,\n      _options$path = _options.path,\n      path = _options$path === undefined ? '/' : _options$path,\n      _options$exact = _options.exact,\n      exact = _options$exact === undefined ? false : _options$exact,\n      _options$strict = _options.strict,\n      strict = _options$strict === undefined ? false : _options$strict;\n\n  var _compilePath = compilePath(path, { end: exact, strict: strict }),\n      re = _compilePath.re,\n      keys = _compilePath.keys;\n\n  var match = re.exec(pathname);\n\n  if (!match) return null;\n\n  var url = match[0],\n      values = match.slice(1);\n\n  var isExact = pathname === url;\n\n  if (exact && !isExact) return null;\n\n  return {\n    path: path, // the path pattern used to match\n    url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL\n    isExact: isExact, // whether or not we matched exactly\n    params: keys.reduce(function (memo, key, index) {\n      memo[key.name] = values[index];\n      return memo;\n    }, {})\n  };\n};\n\nexport default matchPath;"]},"metadata":{},"sourceType":"module"}