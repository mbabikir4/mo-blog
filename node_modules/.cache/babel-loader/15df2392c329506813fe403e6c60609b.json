{"ast":null,"code":"import { isTag } from 'domhandler';\nimport { Picker } from 'selderee';\n/**\r\n * A {@link BuilderFunction} implementation.\r\n *\r\n * Creates a function (in a {@link Picker} wrapper) that can run\r\n * the decision tree against `htmlparser2` `Element` nodes.\r\n *\r\n * @typeParam V - the type of values associated with selectors.\r\n *\r\n * @param nodes - nodes ({@link DecisionTreeNode})\r\n * from the root level of the decision tree.\r\n *\r\n * @returns a {@link Picker} object.\r\n */\n\nfunction hp2Builder(nodes) {\n  return new Picker(handleArray(nodes));\n} // ==============================================\n\n\nfunction handleArray(nodes) {\n  const matchers = nodes.map(handleNode);\n  return (el, ...tail) => flatMap(matchers, m => m(el, ...tail));\n}\n\nfunction handleNode(node) {\n  switch (node.type) {\n    case 'terminal':\n      {\n        const result = [node.valueContainer];\n        return (el, ...tail) => result;\n      }\n\n    case 'tagName':\n      return handleTagName(node);\n\n    case 'attrValue':\n      return handleAttrValueName(node);\n\n    case 'attrPresence':\n      return handleAttrPresenceName(node);\n\n    case 'pushElement':\n      return handlePushElementNode(node);\n\n    case 'popElement':\n      return handlePopElementNode(node);\n  }\n}\n\nfunction handleTagName(node) {\n  const variants = {};\n\n  for (const variant of node.variants) {\n    variants[variant.value] = handleArray(variant.cont);\n  }\n\n  return (el, ...tail) => {\n    const continuation = variants[el.name];\n    return continuation ? continuation(el, ...tail) : [];\n  };\n}\n\nfunction handleAttrPresenceName(node) {\n  const attrName = node.name;\n  const continuation = handleArray(node.cont);\n  return (el, ...tail) => Object.prototype.hasOwnProperty.call(el.attribs, attrName) ? continuation(el, ...tail) : [];\n}\n\nfunction handleAttrValueName(node) {\n  const callbacks = [];\n\n  for (const matcher of node.matchers) {\n    const predicate = matcher.predicate;\n    const continuation = handleArray(matcher.cont);\n    callbacks.push((attr, el, ...tail) => predicate(attr) ? continuation(el, ...tail) : []);\n  }\n\n  const attrName = node.name;\n  return (el, ...tail) => {\n    const attr = el.attribs[attrName];\n    return attr || attr === '' ? flatMap(callbacks, cb => cb(attr, el, ...tail)) : [];\n  };\n}\n\nfunction handlePushElementNode(node) {\n  const continuation = handleArray(node.cont);\n  const leftElementGetter = node.combinator === '+' ? getPrecedingElement : getParentElement;\n  return (el, ...tail) => {\n    const next = leftElementGetter(el);\n\n    if (next === null) {\n      return [];\n    }\n\n    return continuation(next, el, ...tail);\n  };\n}\n\nconst getPrecedingElement = el => {\n  const prev = el.prev;\n\n  if (prev === null) {\n    return null;\n  }\n\n  return isTag(prev) ? prev : getPrecedingElement(prev);\n};\n\nconst getParentElement = el => {\n  const parent = el.parent;\n  return parent && isTag(parent) ? parent : null;\n};\n\nfunction handlePopElementNode(node) {\n  const continuation = handleArray(node.cont);\n  return (el, next, ...tail) => continuation(next, ...tail);\n} // Can be removed after transition to Node 12.\n\n\nfunction flatMap(items, mapper) {\n  return [].concat(...amap(items, mapper));\n}\n\nfunction amap(items, mapper) {\n  const len = items.length;\n  const res = new Array(len);\n\n  for (let i = 0; i < len; i++) {\n    res[i] = mapper(items[i]);\n  }\n\n  return res;\n}\n\nexport { hp2Builder };","map":{"version":3,"sources":["C:/Users/m2bab/VM/rd2/frontend/node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.mjs"],"names":["isTag","Picker","hp2Builder","nodes","handleArray","matchers","map","handleNode","el","tail","flatMap","m","node","type","result","valueContainer","handleTagName","handleAttrValueName","handleAttrPresenceName","handlePushElementNode","handlePopElementNode","variants","variant","value","cont","continuation","name","attrName","Object","prototype","hasOwnProperty","call","attribs","callbacks","matcher","predicate","push","attr","cb","leftElementGetter","combinator","getPrecedingElement","getParentElement","next","prev","parent","items","mapper","concat","amap","len","length","res","Array","i"],"mappings":"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","sourcesContent":["import { isTag } from 'domhandler';\nimport { Picker } from 'selderee';\n\n/**\r\n * A {@link BuilderFunction} implementation.\r\n *\r\n * Creates a function (in a {@link Picker} wrapper) that can run\r\n * the decision tree against `htmlparser2` `Element` nodes.\r\n *\r\n * @typeParam V - the type of values associated with selectors.\r\n *\r\n * @param nodes - nodes ({@link DecisionTreeNode})\r\n * from the root level of the decision tree.\r\n *\r\n * @returns a {@link Picker} object.\r\n */\r\nfunction hp2Builder(nodes) {\r\n    return new Picker(handleArray(nodes));\r\n}\r\n// ==============================================\r\nfunction handleArray(nodes) {\r\n    const matchers = nodes.map(handleNode);\r\n    return (el, ...tail) => flatMap(matchers, m => m(el, ...tail));\r\n}\r\nfunction handleNode(node) {\r\n    switch (node.type) {\r\n        case 'terminal': {\r\n            const result = [node.valueContainer];\r\n            return (el, ...tail) => result;\r\n        }\r\n        case 'tagName':\r\n            return handleTagName(node);\r\n        case 'attrValue':\r\n            return handleAttrValueName(node);\r\n        case 'attrPresence':\r\n            return handleAttrPresenceName(node);\r\n        case 'pushElement':\r\n            return handlePushElementNode(node);\r\n        case 'popElement':\r\n            return handlePopElementNode(node);\r\n    }\r\n}\r\nfunction handleTagName(node) {\r\n    const variants = {};\r\n    for (const variant of node.variants) {\r\n        variants[variant.value] = handleArray(variant.cont);\r\n    }\r\n    return (el, ...tail) => {\r\n        const continuation = variants[el.name];\r\n        return (continuation) ? continuation(el, ...tail) : [];\r\n    };\r\n}\r\nfunction handleAttrPresenceName(node) {\r\n    const attrName = node.name;\r\n    const continuation = handleArray(node.cont);\r\n    return (el, ...tail) => (Object.prototype.hasOwnProperty.call(el.attribs, attrName))\r\n        ? continuation(el, ...tail)\r\n        : [];\r\n}\r\nfunction handleAttrValueName(node) {\r\n    const callbacks = [];\r\n    for (const matcher of node.matchers) {\r\n        const predicate = matcher.predicate;\r\n        const continuation = handleArray(matcher.cont);\r\n        callbacks.push((attr, el, ...tail) => (predicate(attr) ? continuation(el, ...tail) : []));\r\n    }\r\n    const attrName = node.name;\r\n    return (el, ...tail) => {\r\n        const attr = el.attribs[attrName];\r\n        return (attr || attr === '')\r\n            ? flatMap(callbacks, cb => cb(attr, el, ...tail))\r\n            : [];\r\n    };\r\n}\r\nfunction handlePushElementNode(node) {\r\n    const continuation = handleArray(node.cont);\r\n    const leftElementGetter = (node.combinator === '+')\r\n        ? getPrecedingElement\r\n        : getParentElement;\r\n    return (el, ...tail) => {\r\n        const next = leftElementGetter(el);\r\n        if (next === null) {\r\n            return [];\r\n        }\r\n        return continuation(next, el, ...tail);\r\n    };\r\n}\r\nconst getPrecedingElement = (el) => {\r\n    const prev = el.prev;\r\n    if (prev === null) {\r\n        return null;\r\n    }\r\n    return (isTag(prev)) ? prev : getPrecedingElement(prev);\r\n};\r\nconst getParentElement = (el) => {\r\n    const parent = el.parent;\r\n    return (parent && isTag(parent)) ? parent : null;\r\n};\r\nfunction handlePopElementNode(node) {\r\n    const continuation = handleArray(node.cont);\r\n    return (el, next, ...tail) => continuation(next, ...tail);\r\n}\r\n// Can be removed after transition to Node 12.\r\nfunction flatMap(items, mapper) {\r\n    return [].concat(...amap(items, mapper));\r\n}\r\nfunction amap(items, mapper) {\r\n    const len = items.length;\r\n    const res = new Array(len);\r\n    for (let i = 0; i < len; i++) {\r\n        res[i] = mapper(items[i]);\r\n    }\r\n    return res;\r\n}\n\nexport { hp2Builder };\n"]},"metadata":{},"sourceType":"module"}